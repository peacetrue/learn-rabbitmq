= AMQP 0-9-1模型说明

本文对照官网文档 https://www.rabbitmq.com/tutorials/amqp-concepts.html[AMQP 0-9-1 Model Explained^]（链接被丢失）

== 概述

本指南概述了AMQP 0-9-1协议，这是RabbitMQ支持的协议之一。

== AMQP 0-9-1和AMQP模型的高级概述

=== 什么是AMQP 0-9-1？

AMQP 0-9-1（高级消息队列协议）是一种消息传递协议，可使符合要求的客户端应用程序与符合要求的消息传递中间件代理进行通信。

=== 经纪人及其角色

消息传递代理从发布者（发布它们的应用程序，也称为生成器）接收消息，并将它们路由到使用者（处理它们的应用程序）。

由于它是网络协议，因此发布者，使用者和代理都可以驻留在不同的计算机上。

=== AMQP 0-9-1型号简介

AMQP 0-9-1模型具有以下世界视图：消息发布到交换机，通常与邮局或邮箱进行比较。 然后，Exchange使用称为绑定的规则将消息副本分发到队列。 然后，代理将消息传递给订阅队列的消费者，或者消费者根据需要从队列中获取/拉取消息。

image::amqp/hello-world-example-routing.webp[]

发布消息时，发布者可以指定各种消息属性（消息元数据）。某些元数据可能由代理使用，但是，其余部分对代理完全不透明，仅供接收消息的应用程序使用。

网络不可靠，应用程序可能无法处理消息，因此AMQP 0-9-1模型具有消息确认的概念：当消息传递给消费者时，消费者会自动或在应用程序开发人员选择时立即通知代理这样做。当消息确认正在使用时，代理只有在收到该消息（或消息组）的通知时才会从队列中完全删除消息。

在某些情况下，例如，当无法路由消息时，可以将消息返回给发布者，丢弃消息，或者如果代理实现扩展，则将消息放入所谓的“死信队列”中。发布者通过使用某些参数发布消息来选择如何处理这种情况。

队列，交换和绑定统称为AMQP实体。

=== AMQP 0-9-1是可编程协议

AMQP 0-9-1是一种可编程协议，因为AMQP 0-9-1实体和路由方案主要由应用程序本身定义，而不是代理管理员。因此，规定了声明队列和交换，定义它们之间的绑定，订阅队列等的协议操作。

这为应用程序开发人员提供了很大的自由，但也要求他们了解潜在的定义冲突。实际上，定义冲突很少见，通常表明配置错误。

应用程序声明它们需要的AMQP 0-9-1实体，定义必要的路由方案，并且可以选择在不再使用AMQP 0-9-1实体时删除它们。

== 交换和交换类型

交换是发送消息的AMQP 0-9-1实体。交换机接收消息并将其路由到零个或多个队列。使用的路由算法取决于交换类型和称为绑定的规则。 AMQP 0-9-1经纪商提供四种交易所类型：

|===
|名称 |默认的预先声明的名称

|直连交换机
|（空字符串）和 amq.direct

|扇形交换机
|amq.fanout

|主题交换机
|amq.topic

|消息头交换机
|amq.match（和 amq.headers in RabbitMQ）
|===

除了交换类型，交换声明了许多属性，其中最重要的是：

* 名称
* 持久化 (交换生存经纪人重启)
* 自动删除 (当最后一个队列从中取消绑定时删除交换)
* 参数 (可选，由插件和特定于代理的功能使用)

交换可以是持久的或短暂的。经纪人重启后经久耐用的交易活跃，而暂时交易则不然（当经纪人重新上线时，他们必须重新申报）。并非所有场景和用例都要求交换持久。

=== 默认的交换机

默认交换是代理预先声明的没有名称（空字符串）的直接交换。 它有一个特殊的属性，使它对简单的应用程序非常有用：创建的每个队列都使用与队列名称相同的路由键自动绑定到它。

=== 直连交换机

直接交换基于消息路由密钥将消息传递到队列。直接交换对于消息的单播路由是理想的（尽管它们也可以用于多播路由）。下面是它的工作原理：

* 队列使用路由密钥K绑定到交换机
* 当具有路由密钥R的新消息到达直接交换机时，如果K = R，则交换机将其路由到队列

直接交换通常用于以循环方式在多个工作者（同一应用程序的实例）之间分配任务。在这样做时，重要的是要理解，在AMQP 0-9-1中，消息在消费者之间而不是在队列之间进行负载平衡。

直接交换可以用图形表示如下：

image::amqp/exchange-direct.webp[]

=== 扇形交换机

扇出交换将消息路由到绑定到它的所有队列，并忽略路由密钥。如果N队列绑定到扇出交换，则当向该交换发布新消息时，该消息的副本将被传递到所有N个队列。扇出交换是消息广播路由的理想选择。

因为扇出交换将消息的副本传递给绑定到它的每个队列，所以它的用例非常相似：

* 大型多人在线（MMO）游戏可以将其用于排行榜更新或其他全球活动
* 体育新闻网站可以使用扇出交换来近乎实时地向移动客户端分发分数更新
* 分布式系统可以广播各种状态和配置更新
* 群聊可以使用扇出交换在参与者之间分发消息（尽管AMQP没有内置的存在概念，因此XMPP可能是更好的选择）

扇出交换可以用图形表示如下：

image::amqp/exchange-fanout.webp[]

=== 主题交换机

主题基于消息路由密钥与用于将队列绑定到交换的模式之间的匹配来将消息路由到一个或多个队列。主题交换类型通常用于实现各种发布/订阅模式变体。主题交换通常用于消息的多播路由。

主题交换具有非常广泛的用例。每当问题涉及多个消费者/应用程序选择性地选择他们想要接收哪种类型的消息时，应考虑使用主题交换。

示例用途：

* 分发与特定地理位置相关的数据，例如销售点
* 由多个工作人员完成的后台任务处理，每个工作人员能够处理特定的任务集
* 股票价格更新（以及其他类型的财务数据更新）
* 涉及分类或标记的新闻更新（例如，仅针对特定运动或团队）
* 在云中协调不同类型的服务
* 分布式架构/特定于操作系统的软件构建或打包，每个构建器只能处理一个体系结构或操作系统

=== 头交换机

标头交换设计用于在多个属性上进行路由，这些属性更容易表示为消息头而不是路由密钥。标头交换忽略路由密钥属性。相反，用于路由的属性取自headers属性。如果标头的值等于绑定时指定的值，则认为消息是匹配的。

可以使用多个标头将队列绑定到标头交换以进行匹配。在这种情况下，代理需要来自应用程序开发人员的另一条信息，即它是否应该考虑与任何标题匹配的消息，还是所有标题？这就是“x-match”绑定参数的用途。当“x-match”参数设置为“any”时，只需一个匹配的标头值就足够了。或者，将“x-match”设置为“all”，强制所有值必须匹配。

标题交换可视为“类固醇的直接交换”。因为它们基于标头值进行路由，所以它们可以用作直接交换，其中路由密钥不必是字符串;例如，它可以是整数或散列（字典）。

请注意，以字符串x-开头的标题不会用于评估匹配项。

== 队列

AMQP 0-9-1模型中的队列与其他消息和任务排队系统中的队列非常相似：它们存储应用程序使用的消息。队列与交换共享一些属性，但也有一些额外的属性：

* 名称
* 持久（队列将在代理重启后继续存在）
* 独占（仅由一个连接使用，当该连接关闭时将删除队列）
* 自动删除（当最后一个使用者取消订阅时，删除至少有一个使用者的队列）
* 参数（可选;由插件和特定于代理的功能使用，例如消息TTL，队列长度限制等）

在可以使用队列之前，必须声明它。声明队列将导致它创建（如果它尚不存在）。如果队列已经存在并且其属性与声明中的属性相同，则声明将不起作用。当现有队列属性与声明中的队列属性不同时，将引发具有代码406（PRECONDITION_FAILED）的通道级异常。

=== 队列名称

应用程序可以选择队列名称或要求代理为其生成名称。队列名称最多可包含255个字节的UTF-8字符。 AMQP 0-9-1代理可以代表应用程序生成唯一的队列名称。要使用此功能，请将空字符串作为队列名称参数传递。生成的名称将返回给具有队列声明响应的客户端。

队列名称以“amq”开头。保留供经纪人内部使用。尝试声明具有违反此规则的名称的队列将导致带有回复代码403（ACCESS_REFUSED）的通道级异常。

=== 队列耐久性

持久队列持久存储到磁盘，因此可以在代理重启时继续运行。不持久的队列称为瞬态。并非所有场景和用例都要求队列持久。

队列的持久性不会使路由到该队列的消息持久。如果代理被删除然后重新启动，则在代理启动期间将重新声明持久队列，但是，只会恢复持久性消息。

=== 绑定

绑定是交换使用（除其他外）将消息路由到队列的规则。为了指示交换机E将消息路由到队列Q，Q必须绑定到E.绑定可以具有某些交换类型使用的可选路由密钥属性。路由密钥的目的是选择发布到交换机的某些消息以路由到绑定队列。换句话说，路由键的作用类似于过滤器。

用一个类比来说：

* 队列就像您在纽约市的目的地
* 交易所就像肯尼迪机场
* 绑定是从JFK到目的地的路线。可以通过零种或多种方式实现它

拥有这一间接层可以实现使用直接发布到队列不可能或非常难以实现的路由方案，并且还可以消除开发人员必须执行的一定数量的重复工作。

如果无法将消息路由到任何队列（例如，因为没有对其发布的交换的绑定），则会将其删除或返回给发布者，具体取决于发布者设置的消息属性。

== 消费者

除非应用程序可以使用消息，否则将消息存储在队列中是没用的。在AMQP 0-9-1模型中，应用程序有两种方法可以执行此操作：

* 向他们发送消息（“推送API”）
* 根据需要获取消息（“pull API”）

使用“推送API”，应用程序必须表明有兴趣使用来自特定队列的消息。当他们这样做时，我们说他们注册了一个消费者，或者简单地说，他们订阅了一个队列。每个队列可以有多个消费者，或者注册一个独占消费者（在消费时排除队列中的所有其他消费者）。

每个消费者（订阅）都有一个称为消费者标签的标识符。它可用于取消订阅邮件。消费者标签只是字符串。

=== 消息自动应答

消费者应用程序 - 即接收和处理消息的应用程序 - 有时可能无法处理单个消息或有时会崩溃。网络问题也可能导致问题。这提出了一个问题：代理何时应该从队列中删除消息？ AMQP 0-9-1规范让消费者可以控制这一点。有两种确认模式：

* 代理向应用程序发送消息后（使用basic.deliver或basic.get-ok方法）。
* 应用程序发回确认后（使用basic.ack方法）。

前一种选择称为自动确认模型，后一种称为显式确认模型。使用显式模型，应用程序选择何时发送确认。它可以在接收消息之后，或者在处理之前将其持久保存到数据存储之后，或者在完全处理消息之后（例如，成功获取网页，处理并将其存储到某个持久性数据存储中）。

如果消费者在没有发送确认的情况下死亡，则经纪人将其重新发送给另一个消费者，或者如果当时没有消费者，则经纪人将等待至少一个消费者在尝试重新发送之前注册相同的队列。

=== 拒绝消息

当消费者应用程序收到消息时，该消息的处理可能成功也可能不成功。应用程序可以通过拒绝消息向代理指示消息处理已经失败（或者当时无法完成）。拒绝消息时，应用程序可以要求代理放弃或重新排队。当队列中只有一个消费者时，请确保不要通过一次又一次地拒绝和重新排队来自同一消费者的消息来创建无限的消息传递循环。

=== 否定的自动应答

使用basic.reject方法拒绝邮件。 basic.reject有一个限制：无法拒绝多条消息，就像您可以使用确认一样。但是，如果您使用RabbitMQ，那么有一个解决方案。 RabbitMQ提供AMQP 0-9-1扩展，称为否定确认或nack。有关更多信息，请参阅Confirmations和basic.nack扩展指南。

=== 预取消息

对于多个消费者共享队列的情况，能够在发送下一个确认之前指定每个消费者可以一次发送多少消息是有用的。这可以用作简单的负载平衡技术，或者如果消息倾向于批量发布，则可以提高吞吐量。例如，如果生产应用程序由于其正在进行的工作的性质而每分钟发送一次消息。

请注意，RabbitMQ仅支持通道级预取计数，而不支持基于连接或大小的预取。

=== 消息属性和有效负载

AMQP 0-9-1模型中的消息具有属性。有些属性非常常见，AMQP 0-9-1规范定义了它们，应用程序开发人员不必考虑确切的属性名称。一些例子是

* 内容类型
* 内容编码
* 路由键
* 交付模式（持久与否）
* 消息优先级
* 消息发布时间戳
* 到期期限
* 发布者应用标识

AMQP代理使用了一些属性，但大多数属性都可以通过接收它们的应用程序进行解释。某些属性是可选的，称为标题。它们类似于HTTP中的X-Header。发布消息时设置消息属性。

消息还有一个有效载荷（它们携带的数据），AMQP代理将其视为不透明的字节数组。经纪人不会检查或修改有效载荷。消息可能只包含属性而没有有效负载。通常使用序列化格式（如JSON，Thrift，Protocol Buffers和MessagePack）来序列化结构化数据，以便将其作为消息有效负载发布。协议对等体通常使用“内容类型”和“内容编码”字段来传递该信息，但这仅仅是按照惯例。

消息可以作为持久性发布，这使得代理将它们保存到磁盘。如果重新启动服务器，则系统会确保收到的持久消息不会丢失。简单地将消息发布到持久交换或者它被路由到的队列是持久的这一事实不会使消息持久化：这一切都取决于消息本身的持久性模式。将消息发布为持久性会影响性能（就像数据存储一样，持久性会以一定的性能成本）。

在“出版商”指南中了解详情。

== 消息自动应答

由于网络不可靠且应用程序失败，因此通常需要进行某种处理确认。有时只需要确认已收到消息这一事实。有时，确认意味着消息由消费者验证和处理，例如，验证为具有强制数据并持久保存到数据存储或索引。

这种情况非常常见，因此AMQP 0-9-1具有称为消息确认（有时称为acks）的内置功能，消费者可使用该功能来确认消息传递和/或处理。如果应用程序崩溃（AMQP代理在连接关闭时注意到此情况），如果预期确认消息但AMQP代理未收到该消息，则该消息将被重新排队（并且可能立即传递给另一个消费者，如果有的话）存在）。

在协议中内置确认有助于开发人员构建更强大的软件。

== AMQP 0-9-1方法

AMQP 0-9-1的结构可以是多种方法。方法是操作（如HTTP方法），与面向对象编程语言中的方法没有任何共同之处。 AMQP 0-9-1中的协议方法被分组为类。类只是AMQP方法的逻辑分组。 AMQP 0-9-1参考文献包含所有AMQP方法的完整详细信息。

让我们来看看交换类，一组与交易所操作相关的方法。它包括以下操作：

* exchange.declare
* exchange.declare-ok
* exchange.delete
* exchange.delete-ok

（请注意，RabbitMQ站点引用还包括交换类的RabbitMQ特定扩展，我们将不在本指南中讨论）。

上面的操作形成逻辑对：exchange.declare和exchange.declare-ok，exchange.delete和exchange.delete-ok。这些操作是“请求”（由客户端发送）和“响应”（由经纪人响应上述“请求”而发送）。

例如，客户端要求代理使用exchange.declare方法声明新的交换：

image::ampq/exchange-declare.webp[]

如上图所示，exchange.declare带有几个参数。它们使客户端能够指定交换名称，类型，持久性标志等。

如果操作成功，代理将使用exchange.declare-ok方法进行响应：

image::ampq/exchange-declare-ok.webp[]

exchange.declare-ok除了通道号之外不带任何参数（通道将在本指南的后面部分介绍）。

对于AMQP 0-9-1队列方法类上的另一个方法对，事件序列非常相似：queue.declare和queue.declare-ok：

image::ampq/queue-declare.webp[]

image::ampq/queue-declare-ok.webp[]

并非所有AMQP 0-9-1方法都有对应物。一些（basic.publish是最广泛使用的）没有相应的“响应”方法，而另一些（例如，basic.get）具有多个可能的“响应”。

== 链接

AMQP 0-9-1连接通常是长期存在的。 AMQP 0-9-1是一个使用TCP进行可靠传递的应用程序级协议。 Connections使用身份验证，可以使用TLS进行保护。当应用程序不再需要连接到服务器时，它应该正常关闭其AMQP 0-9-1连接，而不是突然关闭底层TCP连接。

== 通道

某些应用程序需要多个连接到代理。但是，不希望同时打开许多TCP连接，因为这样做会消耗系统资源并使配置防火墙变得更加困难。 AMQP 0-9-1连接与可被视为“共享单个TCP连接的轻量级连接”的通道复用。

客户端执行的每个协议操作都发生在一个通道上。特定信道上的通信与另一个信道上的通信完全分开，因此每个协议方法还携带一个信道ID（例如信道号），这是一个整数，代理和客户端都使用该整数来确定该方法的用途。

通道仅存在于连接的上下文中，而不是单独存在。当连接关闭时，它上面的所有通道也是如此。

对于使用多个线程/进程进行处理的应用程序，每个线程/进程打开一个新通道并且不在它们之间共享通道是很常见的。

== 虚拟主机

为了使单个代理能够托管多个隔离的“环境”（用户组，交换，队列等），AMQP 0-9-1包含虚拟主机（虚拟主机）的概念。它们类似于许多流行的Web服务器使用的虚拟主机，并提供AMQP实体所在的完全隔离的环境。协议客户端指定在连接协商期间要使用的vhost。

== AMQP是可扩展的

AMQP 0-9-1有几个扩展点：

* 自定义交换类型允许开发人员实现路由方案，交换类型提供的交换类型不能很好地覆盖，例如，基于地理数据的路由。
* 交换和队列声明可以包括代理可以使用的其他属性。例如，RabbitMQ中的每队列消息TTL以这种方式实现。
* 特定于代理的经纪人扩展。例如，请参阅RabbitMQ实现的扩展。
* 可以引入新的AMQP 0-9-1方法类。
* 可以使用其他插件扩展代理，例如，RabbitMQ管理前端和HTTP API作为插件实现。

这些特性使AMQP 0-9-1型号更加灵活，适用于各种各样的问题。

== AMQP 0-9-1客户生态系统

许多流行的编程语言和平台都有许多AMQP 0-9-1客户端。其中一些术语严格遵循AMQP术语，仅提供AMQP方法的实现。其他一些还有其他功能，便利方法和抽象。一些客户端是异步的（非阻塞），一些是同步的（阻塞），一些客户端支持两种模型。某些客户端支持特定于供应商的扩展（例如，RabbitMQ特定的扩展）。

由于AMQP的主要目标之一是互操作性，因此开发人员理解协议操作并不限于特定客户端库的术语是个好主意。这样与使用不同库的开发人员进行通信将变得非常容易。

== 获得帮助并提供反馈

如果您对本指南的内容或与RabbitMQ相关的任何其他主题有疑问，请不要犹豫，在RabbitMQ邮件列表中询问他们。

== 帮助我们改进文档<3

如果您想对网站做出改进，可以在GitHub上找到它的来源。只需分叉存储库并提交拉取请求。谢谢！






















